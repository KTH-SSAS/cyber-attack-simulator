#!/usr/bin/env bash

set -euo pipefail

self=${0##*/}
name=$self
cluster=$self-cluster
head=$cluster-ray-head
k8s=0

! [ "${1-}" ] || ! [ . = ${1::1} ] ||
    {
        if [ . = "$1" ]
        then ((++k8s))
        else name+=$1
        fi
        shift
    }

push=europe-west4-docker.pkg.dev/sentience-reinforce/images/$name

if [[ "$(git config remote.origin.url 2>/dev/null)" = *pontusj/openai_attack_simulation* ]]
then context="$(git rev-parse --show-toplevel)"
else context="$(dirname "$(cd "$(dirname "$0")" && pwd)")"
fi
dockerfile="$context/docker/Dockerfile"
home="$(dirname "$(sed -n '/WORKDIR/{s/[^/]*//;p;}' "$dockerfile")")"

# see if URL:s can easily be opened
case $(uname -s) in
    (Darwin)
        open=open
        ;;
    (Linux)
        ! command -pv xdg-open || open=xdg-open
esac
[ "${open-}" ] || open="echo open the following URL in your browser: "


_get_pod() {
    [ "${pod-}" ] ||
        pod=$(kubectl get pod --selector cluster.ray.io/component=$head --output name)
}

_remove_forwarding() {
    ! pid=$(pgrep -fx "kubectl port-forward pod/$head-.* [0-9]*:*$1") || kill $pid
}

_forward() {
    _get_pod
    forward="kubectl port-forward $pod ${2:+$2:}$1"
    # terminate previous forwarders, if any
    _remove_forwarding $1
    log="$HOME/.kfwd-$1.log"
    $forward <&- >& "$log" &
    grep -qm2 ^Forwarding < <(tail -f "$log")
    sleep .1
}

_open() {
    ! ((k8s)) || _forward $1
    $open http://127.0.0.1:$1
}

_kill_children_on_exit() {
    trap : EXIT TERM INT
    kill 0
    wait
}

_open_on_match() {
    match=$(mktemp)
    trap _kill_children_on_exit EXIT TERM INT
    {
        grep -qm1 :$1/
        _open $1
        rm -f $match
        exit
    } < <(tail -f $match) >& /dev/null &
}

_exec() {
    if ((k8s))
    then _get_pod && kubectl exec --stdin --tty $pod -- "${@:-bash}"
    else docker exec --interactive --tty $name "${@:-bash}"
    fi
}

_bail() {
    echo $'\x1b[1;31m'"$@"$'\x1b[m'
    exit 1
}

_check() {
    ((k8s)) || [ "$(docker ps --filter name=$name --format '{{.Names}}')" = "$name" ]
}

_run() {
    args=(
        --name $name
        --rm
        --interactive
        --tty
        --memory $((1<<33))  # 8GiB
        --shm-size $(((1<<33)/3))  # > 30% of 8GiB
        --publish 127.0.0.1:8265:8265  # Ray dashboard
        --publish 127.0.0.1:6006:6006  # TensorBoard
        --publish 127.0.0.1:8888:8888  # JupyterLab
    )
    for path in .gitconfig
    do ! [ -r "$HOME/$path" ] || args+=(--volume "$HOME/$path:$home/$path:ro")
    done

    ssh="${OAS_SSH_DIR-$HOME/.ssh}"
    if [ "$ssh" ]
    then
        echo $'\x1b[1;33m'
        echo Using \'$ssh\' as OAS_SSH_DIR...
        echo
        echo To use an alternate path, set the environment variable OAS_SSH_DIR.
        echo Setting OAS_SSH_DIR to the empty string \"\" disables SSH directory mapping.
        echo $'\x1b[m'
        [ / = "${ssh::1}" ] || _bail OAS_SSH_DIR needs to be an absolute path
        [ -d "$ssh" ] || _bail OAS_SSH_DIR must point to a directory
        keys=0
        for key in "$ssh/id_"*
        do
            ! ssh-keygen -lf "$key" || ((++keys))
        done
        ((keys)) || _bail OAS_SSH_DIR must contain an SSH key
        args+=(--volume "$ssh:$home/.ssh")
    fi

    for repl in bash python
    do
        history="$HOME/.${name}_${repl}_history"
        touch "$history"
        args+=(--volume "$history:$home/.${repl}_history:rw")
    done

    num_cli_args=$1
    shift
    # put original command-line arguments last to allow override
    args+=("${@:1:$num_cli_args}")
    shift $num_cli_args
    docker run "${args[@]}" $name "$@"
}

_spawn() {
    if _check
    then _exec "$@"
    else _run 0 "$@"
    fi
}

case ${1-} in
    build)
        find "$context" -type d -name __pycache__ -exec rm -vfr {} +
        rm -vfr "$context"/.{tox,coverage}
        shift
        # put original command-line arguments last to allow override
        docker build --tag $name --file "$dockerfile" "$@" "$context"
        ;;
    push)
        # support multi-arch images (tags _may_ need to include more info to be unique)
        tag=$push-$(uname -m)
        docker tag $name $tag
        docker push $tag
        platform="$(docker manifest inspect --verbose $tag | jq -cr .Descriptor.platform)"
        # purge any local copies of our manifest
        docker manifest rm $push || : manifest need not exist, OK to fail here
        # get a list of included image hashes **for other platforms** (if any)
        others=(
            $(docker manifest inspect $push |
                jq -cr '.manifests[] | select(.platform != '"$platform"').digest')
        )
        # create a new manifest
        docker manifest create $push $tag
        # append pre-existing images (for other platforms)
        ! ((${#others[*]})) ||
            docker manifest create --amend $push $(printf "$push@%s " "${others[@]}")
        # push the updated manifest and remove any local copies
        docker manifest push --purge $push
        ;;
    run)
        shift
        if ((1 == $#)) && [ - = "$1" ] 
        then docker rm --force $(docker ps --all --quiet --filter name=$name)
        else _run $# "$@"
        fi
        ;;
    kfwd)
        if [ - = "${3-}" ]
        then _remove_forwarding $2
        else _forward $2 ${3-}
        fi
        ;;
    dash)
        if [ - = "${2-}" ]
        then _remove_forwarding 8265
        else _open 8265
        fi
        ;;
    tboard)
        _open_on_match 6006
        _exec tensorboard --bind_all --logdir $home/ray_results | tee $match
        ;;
    jlab)
         _open_on_match 8888
        _spawn jupyter-lab --allow-root --no-browser --ip=0.0.0.0 | tee $match
        ;;
    shell)
        _spawn
        ;;
    exec)
        shift
        _exec "$@"
        ;;
    *)
        cat << USAGE
Usage: $self [.[FLAVOR]] [COMMAND [ARGS]]

Convenience wrapper for working with Docker and Kubernetes based on this repo.

When an optional .FLAVOR (the leading dot is important!) is specified,
the corresponding image and container will be called '$self.FLAVOR' [$name].

Using ONLY a single dot as the first argument activates Kubernetes mode.
Some Docker-only commands ignore Kubernetes mode.  (See below!)
Kubernetes mode assumes that the current active context points to '$cluster',
and master access from this host is enabled.

The following COMMAND arguments are available:

- build [ARGS]          builds an image [$name] from the current checkout
                        ARGS are passed to 'docker build' (overriding script defaults)
                        Docker-only, Kubernetes mode IGNORED

- push                  pushes the image [$name] to the pre-configured repository
                        '$push'
                        no ARGS, Docker-only, Kubernetes mode IGNORED

- run [ARGS|-]          runs a container [$name] using the image [$name]
                        ARGS are passed to 'docker run' (overriding script defaults)
                        the special argument '-' stops/removes the [$name] container
                        Docker-only, Kubernetes mode IGNORED

- exec [CMD ARGS]       executes CMD ARGS in a container or the head pod in Kubernetes
                        when no CMD is given, 'bash' is executed by default
                        (in Docker mode, fails if no container is available)

- dash [-]              opens the Ray dashboard in a browser
                        only useful if Ray is actually up and running
                        (either locally in a container or in the cluster)
                        in Kubernetes mode, the special argument '-' clears port-forwarding

- tboard                launches 'tensorboard' in a local container or in the head pod
                        and opens a browser window to access its web-UI
                        (in Docker mode, fails if no container is available)

- jlab                  launches 'jupyterlab' in a local container or in the head pod
                        and opens a browser window to access its web-UI
                        (in Docker mode, also starts a container, if needed)

- shell                 spawns 'bash' in a local container or in the head pod
                        (in Docker mode, also starts a container, if needed)

- kfwd PORT [-|LOCAL]   sets up Kubernetes port-forwarding towards the Ray head pode for PORT
                        only useful if the Ray cluster is up and running and uses that PORT
                        the special argument '-' clears the same port-forwarding
                        an optional LOCAL port can be specified to handle conflicts
                        ALWAYS works towards Kubernetes irrespective of ./.FLAVOR
USAGE
        exit 1
        ;;
esac
